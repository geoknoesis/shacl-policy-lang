<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>SHACL Policy Language</title>
  <script class="remove" src="https://www.w3.org/Tools/respec/respec-w3c" defer></script>
  <script class="remove" src="respec-config.js"></script>

  </head>
  <body>
    <section id="abstract">
      <h2>Abstract</h2>
      <p>
        SHACL Policy Language is a proposal for a shapes-based access control policy language that leverages W3C's Shapes Constraint Language (SHACL) to express fine-grained access conditions for protected resources using attributes from Verifiable Credentials. This specification defines a vocabulary and model for writing access control rules as SHACL shapes, enabling attribute-based access control (ABAC) in decentralized systems. By using SHACL's well-defined validation semantics [[SHACL]], SHACL Policy Language allows policy authors to specify complex constraints (e.g., "the user must possess a credential with attribute X and value Y") in an interoperable, extensible manner. The approach is informed by existing W3C standards and community efforts - including ODRL-based policy profiles [[OAC]] [[ODRL-VC]] and emphasizes integration with the W3C Verifiable Credentials data model [[VC-DATA-MODEL]] to support real-world use cases. The goal is to provide a W3C-style access control specification that is easy to adopt, maintain, and integrate across diverse platforms by reusing familiar SHACL validation tools and patterns.
      </p>
    </section>

    <section id="sotd">
      <h2>Status of This Document</h2>
      <p>
        This document is a draft specification for discussion within the W3C community (e.g., a Credentials Community Group or Working Group). It has no official standing yet and does not represent an established standard. Feedback and contributions are welcome. The specification may change based on community input and further evaluation. This document is prepared in the style of a W3C specification to facilitate review.
      </p>
      <p>
        This draft incorporates insights from existing policy frameworks, including the Open Digital Rights Language (ODRL) (a W3C Recommendation for policy expression) and research prototypes like [[SHACL-ACL]]. The decision to pursue a SHACL-based vocabulary (as opposed to an ODRL profile) reflects the analysis of interoperability, community adoption, and extensibility presented in the Introduction.
      </p>
    </section>

    <section id="introduction">
      <h2>Introduction</h2>
        <p>
            Access control policies in decentralized systems often need to make authorization decisions based on attributes or claims - for example, allowing access only to users over a certain age, or only to members of a given organization. With the advent of Verifiable Credentials (VCs) as a standard way to express and cryptographically prove attributes about an entity, there is a growing need for a policy language that can consume these credentials and enforce fine-grained, attribute-based access rules. This specification addresses that need by defining SHACL Policy Language, a policy language that uses SHACL shapes to specify the conditions under which access is granted or denied.
        </p>

        <section id="background">
            <h3>Background and Motivation</h3>
            <h4>W3C Practices & Existing Approaches</h4>
            <p>
                A natural question is whether to build on an existing W3C policy framework (such as ODRL, the Open Digital Rights Language) or to create a new vocabulary tailored to this use case. ODRL is a W3C Recommendation designed for expressing rules about content use and licensing, and it has been repurposed for access control scenarios in some communities. For example, the Solid Project and others have explored an ODRL Profile for Access Control (OAC) to express permissions and prohibitions on data in decentralized data pods [[OAC]]. Additionally, the Gaia-X initiative has developed an ODRL profile for attribute-based access control using Verifiable Credential claims [[ODRL-VC]], demonstrating that ODRL can be extended to reference VC attributes in policy constraints. These efforts validate the feasibility of an ODRL-based solution and align with W3C's general practice of reusing and profiling existing standards for new domains.
            </p>
            <p>
                However, while ODRL provides a rich information model (policies, rules, duties, constraints, etc.), it does not natively define an execution semantics for evaluating access control decisions. In other words, ODRL policies describe what is permitted or prohibited, but the standard leaves it to implementations to determine how to enforce those rules. Projects using ODRL for access control have had to create custom evaluation logic or supplemental frameworks (for example, using SHACL or hard-coded checks) to decide if a given request satisfies the policy. This can introduce complexity and reduce interoperability, as different implementations might handle policy evaluation differently. Moreover, adding new kinds of constraints (e.g., checking the content of a verifiable credential) may require defining new ODRL vocabulary terms ("left operands") and custom processing, raising questions of maintainability and extensibility.
            </p>

            <h4>SHACL-Based Approach</h4>
            <p>
                SHACL (Shapes Constraint Language) is a W3C Recommendation widely adopted for validating RDF data against a set of conditions (integrity constraints) [[SHACL]]. The key insight behind SHACL Policy Language is that access control rules can be viewed as data integrity constraints on a combined graph of "contextual information" (such as user credentials, resource attributes, and environment data). If all the constraints are satisfied, the access request is authorized; if any constraint is violated, access is denied. This approach was notably demonstrated by SHACL-ACL (SHACL Access Control Lists), which uses SHACL shapes to enforce graph-based access rules [[SHACL-ACL]]. SHACL provides a clear execution model: a shape either validates (passes) or violates (fails) given a data graph, based on formally-defined semantics. This well-defined evaluation mechanism is a strong advantage for using SHACL in policy evaluation. In fact, researchers have argued it is "natural to specify [access policies] in SHACL; the semantics of SHACL validation are well-defined". SHACL's extensibility (via new shapes, SPARQL-based constraints, etc.) also allows incorporating external or dynamic data if needed, which is important in real-world scenarios (e.g., checking an attribute from an external API or a real-time context like time of day).
            </p>

            <h4>Decision (Profile ODRL vs. Standalone)</h4>
            <p>
                After evaluating these considerations - W3C practices, community adoption, interoperability, maintainability, and extensibility - this specification takes the approach of defining a standalone SHACL-based vocabulary for access control policies (nicknamed "SHACL Policy Language"), rather than treating it as an ODRL profile. The rationale for this choice includes:
            </p>
            <ul>
                <li><strong>Interoperability & Tooling:</strong> SHACL Policy Language leverages existing SHACL validation engines, which are widely available in RDF ecosystems (many triple stores and libraries support SHACL). This means policy evaluation can be integrated with minimal new code: essentially, policies are SHACL shapes evaluated on data graphs containing credentials and context. In contrast, an ODRL-based approach would require either extending an ODRL engine or custom-coding the evaluation of new constraint types (e.g., VC-specific constraints), since ODRL's processing model for such constraints is not standardized. By aligning with SHACL, we gain immediate interoperability with standard tooling.</li>
                <li><strong>Community Familiarity and Adoption:</strong> The Semantic Web community is already familiar with SHACL for data validation. Reusing SHACL for policies means a lower learning curve for developers and researchers who work with RDF graphs. In contrast, ODRL - while standardized - represents an additional conceptual model (policies, rules, duties) that developers must learn, and its usage for access control is still emerging (in projects like Solid and Gaia-X). SHACL Policy Language focuses on a simpler model (essentially, policies as shapes) which may encourage adoption, especially in communities already using SHACL (e.g., for validating credential schemas or knowledge graph integrity).</li>
                <li><strong>Maintainability:</strong> The SHACL Policy Language vocabulary defined here is relatively small and focused. It defines just the necessary classes and properties to represent policies and relies on SHACL's semantics for evaluation. This makes it easier to maintain and evolve within a focused community group. While ODRL is mature and maintained by a broader community, creating an ODRL profile for every new domain can introduce overhead; the profile must track the base ODRL model and potentially wait for ODRL updates for new features. A standalone SHACL-based spec can evolve independently as needs arise, while still coexisting with ODRL (indeed, nothing prevents mapping or translating SHACL Policies to ODRL expressions in the future if needed for interoperability).</li>
                <li><strong>Extensibility:</strong> SHACL's constraint model is highly extensible new conditions can be expressed simply by writing new shapes or using SHACL-SPARQL for custom logic. For example, if a future use case needs to check a complex condition involving multiple credentials or external data, one can craft a SHACL shape to do so (potentially using SPARQL within SHACL) without needing to introduce new vocabulary terms at the policy level. ODRL, on the other hand, typically requires new constraint terms (leftOperands) or profile-specific extensions to handle novel conditions, which can fragment the ecosystem if different profiles define overlapping concepts differently. By building on a general-purpose constraint language, SHACL Policy Language can accommodate a wide range of conditions under a single framework. As demonstrated by [[SHACL-ACL]], even data from heterogeneous sources can be incorporated by mapping them into RDF for SHACL to consume.</li>
                <li><strong>Alignment with Verifiable Credentials:</strong> Since VCs are often represented (or can be represented) as JSON-LD, they already have a well-defined RDF mapping (the W3C VC Data Model defines an RDF context for credentials). SHACL shapes can naturally navigate and test the content of these credential graphs. This alignment makes a SHACL-based approach particularly apt for VC-driven policies. (By contrast, an ODRL profile would need to introduce a way to reference credential claims, as the Gaia-X profile does with custom "ovc:" vocabulary, effectively embedding JSONPath or similar references to VC fields in ODRL constraints. That approach is workable but adds a layer of indirection and custom parsing logic that SHACL can avoid by directly operating on the RDF form of credentials.)</li>
            </ul>
            <p>
                In summary, SHACL Policy Language is chosen as a standalone SHACL-based vocabulary for specifying access control rules. This choice is made to maximize clarity of semantics, ease of implementation, and alignment with existing technologies. It does not preclude future interoperability with ODRL; indeed, one could envision a complementary ODRL profile or a mapping such that SHACL Policies could be translated to an ODRL expression for compatibility. However, the focus of this document is defining SHACL Policy Language on its own terms as a candidate solution for the community.
            </p>
        </section>

        <section id="overview">
            <h3>Overview of this Specification</h3>
            <p>The remainder of this specification is organized as follows:</p>
            <ul>
                <li><strong>Use Cases:</strong> Describes typical scenarios that motivate SHACL Policy Language, illustrating the kinds of access rules and credential usages that need to be supported.</li>
                <li><strong>Vocabulary Overview:</strong> Introduces the core concepts (Policy, conditions, actions, etc.) and how they relate at a high level.</li>
                <li><strong>SHACL Policy Language Model (Normative):</strong> Provides the formal definition of the SHACL Policy Language vocabulary, including classes, properties, and constraints, along with normative requirements (MUST/MAY) for conformant policies.</li>
                <li><strong>Integration with Verifiable Credentials:</strong> Explains how the policy model works with W3C Verifiable Credentials, including data model alignment and verification considerations.</li>
                <li><strong>SHACL Policy Language Evaluation Semantics:</strong> Defines how to evaluate an access request against SHACL policies, the decision process (allow/deny), and how multiple policies are combined.</li>
                <li><strong>Examples:</strong> Gives concrete examples of SHACL Policy Language in action (in Turtle syntax), demonstrating real-world policy rules such as age-based access and role-based access using VCs.</li>
                <li><strong>Appendix: RDF/Turtle Vocabulary:</strong> Provides an authoritative Turtle serialization of the SHACL Policy Language vocabulary for reference and use in implementations.</li>
            </ul>
        </section>
    </section>

    <section id="use-cases">
      <h2>Use Cases</h2>
      <p>
        SHACL Policy Language is designed to address Attribute-Based Access Control (ABAC) in scenarios where attributes are conveyed via Verifiable Credentials. Below are some motivating use cases:
      </p>
      <ul>
        <li>
          <strong>Age-Restricted Content:</strong> A video streaming service offers certain content only to adults (18+). To enforce this, a policy requires that the user present a government-issued credential (e.g., an ID credential) proving their age is above 18. The SHACL Policy Language condition checks the birthdate or age claim in the credential against the required threshold. If the condition is not satisfied (no valid proof of age), access is denied.
        </li>
        <li>
          <strong>Role-Based Data Access:</strong> An enterprise data portal restricts editing rights to users who hold a "Manager" role credential issued by the company. A SHACL Policy Language encodes that the user's credentials must include an employment credential with role Manager and issuer CompanyX. Only if a valid credential with those attributes is present will the policy's SHACL shape validate successfully, allowing the edit action.
        </li>
        <li>
          <strong>Membership and Group Access:</strong> A restricted online community permits access only to members of a certain organization or club. For example, only members of the "Alumni Association" (as evidenced by an alumni credential) can access the alumni forum. The policy's condition requires a credential with `memberOf` Alumni Association. Users lacking such a credential (or with an invalid one) will fail the policy check.
        </li>
        <li>
          <strong>Combination of Attributes (Multiple Credentials):</strong> A healthcare data access scenario might require that a requester is both a licensed doctor and is currently affiliated with a hospital. This can be represented as two credentials—a medical license credential and an employment credential. A SHACL Policy Language can enforce that at least one credential meets each of these criteria. (This can be done with multiple shapes or a single shape using logical constraints like `sh:and` or qualified value constraints to ensure the presence of each type of credential.) Only if both conditions are met (license and hospital affiliation) is access granted.
        </li>
        <li>
          <strong>Contextual and Temporal Constraints:</strong> Some access might depend on dynamic or context attributes, such as time of access or current location, possibly conveyed via a credential or an external data feed. For instance, a policy could allow access to a resource only during certain hours and only if the user presents a "Clearance Level 5" credential. SHACL's expressiveness allows inclusion of such constraints (time constraints could be handled by comparing to a known literal or by incorporating a current-time resource via extension mechanisms). While the current specification focuses on credential-based attributes, it is extensible to include context data in the evaluated graph.
        </li>
      </ul>
      <p>These use cases illustrate the need for a flexible policy language that can handle attributes from one or more VCs, numeric and categorical constraints, and logical combinations of conditions. SHACL Policy Language addresses these requirements by using shapes to naturally express "constraints" that mirror the access rules in these scenarios.</p>
    </section>

    <section id="vocabulary-overview">
        <h2>Vocabulary Overview</h2>
        <p>At a high level, SHACL Policy Language introduces a small number of classes and properties to represent access control policies and their components:</p>
        <ul>
            <li><strong>Policy</strong> - the central class representing an access control policy rule. A Policy encapsulates:
                <ul>
                    <li>The target resource to which it applies (for example, a URI or an RDF class of resources).</li>
                    <li>The allowed action (operation) on that resource (e.g., read, write).</li>
                    <li>A condition in the form of a SHACL shape that must be satisfied by the request context (including the user's credentials) for access to be granted or denied.</li>
                    <li>An effect indicating whether the policy is granting permission or explicitly denying it, which can be distinguished by using sub-classes or a property.</li>
                </ul>
            </li>
            <li><strong>AllowPolicy and DenyPolicy</strong> - two subclasses of Policy (or types of policy) that indicate the effect of the policy:
                <ul>
                    <li>An <strong>AllowPolicy</strong> specifies conditions under which an action is permitted. If its condition shape is satisfied, the access is allowed (assuming no other overriding deny).</li>
                    <li>A <strong>DenyPolicy</strong> specifies conditions under which an action is forbidden. If its condition is satisfied, the access is denied (regardless of other allows). Deny policies are typically used for exceptions or to enforce negative constraints (e.g., "deny access if the user is under 13 years old").</li>
                </ul>
            </li>
            <li><strong>Action</strong> - a class (or enumeration) representing the type of operation being controlled. Common examples of actions include <code>shpl:Read</code> (for read/view access) and <code>shpl:Write</code> (for write/modify access), defined in this specification. Policies reference actions to indicate what operation they govern. The Action class can be extended or individuals can be created for domain-specific actions (e.g., <code>shpl:Delete</code>, <code>shpl:Append</code>) as needed, or external action vocabularies could be used.</li>
            <li><strong>Resource Targeting</strong> - Policies may need to indicate which resource(s) or resource types they apply to. This is done via the <code>shpl:target</code> property on a Policy, whose value can be:
                <ul>
                    <li>A specific resource IRI (if the policy is about a particular named resource).</li>
                    <li>A class or category of resources (if the policy applies to all resources of a certain type, e.g., "all documents classified as confidential").</li>
                    <li>In practice, one might also attach policies to resources via some link (for example, a resource could link to a policy that governs it). This specification keeps it simple by allowing the policy itself to carry the target reference.</li>
                </ul>
            </li>
            <li><strong>Condition (SHACL Shape)</strong> - Each Policy has a <code>shpl:condition</code> property linking to a SHACL NodeShape that encodes the constraint to evaluate. This shape is typically defined to validate an "access request" data structure that includes information about the requester (credentials, identity) and the context. For instance, the shape might ensure "there exists at least one credential with claim $X=Y$ and issued by $Z$". If the shape's conditions are met (i.e., the data graph conforms to the shape), then the policy's requirements are satisfied. The shape can be as simple or complex as needed: multiple constraints can be combined within one shape using SHACL's logical operators (<code>sh:and</code>, <code>sh:or</code>, <code>sh:xone</code>, etc.) or qualified value constraints. This approach leverages the full power of SHACL to express conditions on RDF data.</li>
            <li><strong>Access Request (Data Model for Evaluation)</strong> - While not a formal part of the static vocabulary that needs to be stored, we define an AccessRequest conceptual structure in the data that will be validated by the shape. An AccessRequest can be represented as an RDF node (e.g., a blank node or a URI representing the current request) with properties providing:
                <ul>
                    <li>the agent (e.g., the user's identifier or DID),</li>
                    <li>the action being attempted,</li>
                    <li>the target resource being accessed,</li>
                    <li>the credentials presented by the agent (as one or more linked credential nodes, which in turn contain the claims).</li>
                </ul>
                The SHACL condition shapes are written to validate this AccessRequest node. For example, a shape might target <code>shpl:AccessRequest</code> and include a property path into <code>shpl:credential</code> to check certain fields on the credential. The AccessRequest class and its properties (agent, credential, etc.) serve as a bridge between the abstract policy and the concrete data against which it's evaluated. (In a running system, the AccessRequest data would be assembled at runtime by the policy engine when a user attempts an action.)
            </li>
        </ul>
        <p>Overall, the SHACL Policy Language vocabulary is minimal. It reuses wherever possible: SHACL vocabulary (specifically, the entire machinery of shapes, constraints, and validation). Verifiable Credentials vocabulary (for describing credentials and their contents, e.g., using <code>cred:credentialSubject</code>, standard claim predicates, etc., as detailed later). Optionally, existing access control vocabularies for agent or resource identifiers (for example, an agent might be a <code>foaf:Agent</code> or a <code>schema:Person</code>, but the policy doesn't deeply inspect those beyond using them as identifiers or linking credentials to them).</p>
        <p>In the next section, we formally define the SHACL Policy Language model, including the RDF classes and properties mentioned, along with their expected usage. This provides the normative framework for writing policies. Subsequent sections will then cover how to use these in conjunction with Verifiable Credentials and how to evaluate policies at runtime.</p>
    </section>

    <section id="policy-model" class="normative">
        <h2>SHACL Policy Language Model</h2>
        <p>This section defines the SHACL Policy Language vocabulary and model formally. Vocabulary terms introduced here are in the <code>shpl:</code> namespace (a hypothetical namespace for SHACL Policy Language, e.g., <code>https://w3id.org/shacl-policy-language#</code>). The normative statements use keywords like MUST, SHOULD, and MAY according to [[RFC2119]].</p>

        <section id="policy-classes">
            <h3>Policy and Effect Classes</h3>
            <dl>
                <dt><code>shpl:Policy</code></dt>
                <dd>An RDF class representing an access control policy. A Policy is a rule that associates a condition with an access outcome (allow or deny) for a given action on a resource. Every policy instance MUST have the properties defined below (target, action, condition, and an implied effect via subclass or property).</dd>
                <dt><code>shpl:AllowPolicy</code></dt>
                <dd>A subclass of <code>shpl:Policy</code> indicating that it is an "allow" rule. If an instance of AllowPolicy's condition is satisfied for a given request, that contributes to granting access. Formally, an instance of <code>shpl:AllowPolicy</code> MUST be interpreted as a policy that permits the specified action on the target when its condition holds. (If no allow policy's condition holds, then by default the action is not permitted unless some other mechanism allows it.)</dd>
                <dt><code>shpl:DenyPolicy</code></dt>
                <dd>A subclass of <code>shpl:Policy</code> indicating a "deny" rule. If the condition of a DenyPolicy is satisfied, access MUST be denied, even if other allow policies might permit it. This provides the ability to specify exceptions or strict prohibitions. An instance of <code>shpl:DenyPolicy</code> MUST be interpreted as a policy that forbids the action on the target when its condition holds.</dd>
            </dl>
            <p><strong>Effect Semantics:</strong> An implementation MUST distinguish between <code>shpl:AllowPolicy</code> and <code>shpl:DenyPolicy</code> to know how to apply the policy's result. (See the Evaluation Semantics section for the algorithm.) If a Policy is not explicitly typed as either, it SHOULD be treated as an allow rule by default (unless the system has another way to infer effect). It is RECOMMENDED to always use one of the subclasses to avoid ambiguity.</p>
        </section>

        <section id="policy-properties">
            <h3>Policy Properties</h3>
            <p>Each <code>shpl:Policy</code> (or its subclasses) uses the following properties to define its scope and rule:</p>
            <dl>
                <dt><code>shpl:target</code> (IRI or class, required)</dt>
                <dd>The resource or resource class to which this policy applies. A Policy MUST have at least one <code>shpl:target</code> value. If multiple targets are present, the policy applies to all those resources (i.e., it is applicable when the requested resource matches any one of the targets). The object of <code>shpl:target</code> can be:
                    <ul>
                        <li>A specific resource URI (e.g., <code>&lt;https://example.com/resource/123&gt;</code>).</li>
                        <li>A class or category (e.g., <code>ex:SensitiveResource</code>) to indicate a policy that covers all instances of that class.</li>
                        <li>A broader identifier like a URI prefix or pattern (though this spec does not define a pattern syntax; such usage would be non-normative or left to extensions).</li>
                    </ul>
                    <p><strong>Conformance:</strong> When evaluating a policy against an access request (which includes a specific target resource), an implementation MUST ensure the policy's <code>shpl:target</code> matches the requested resource. If there is no match, the policy is not applicable. The exact matching algorithm (especially for class targets) is out of scope of this spec but typically involves checking RDF types or identity equality. For simple URI targets, a match is a URI equality comparison.</p>
                </dd>
                <dt><code>shpl:action</code> (IRI, required)</dt>
                <dd>The action (operation) that the policy governs. A Policy MUST have exactly one <code>shpl:action</code> property, whose value is an IRI representing the action. Only if the access request's action matches this value is the policy considered applicable. The SHACL Policy Language namespace defines a few common actions (see Actions below), but this property can point to any IRI (including those in other vocabularies like the Solid ACL's <code>acl:Read</code> or ODRL actions) as long as both policy and request refer to the same IRI for the action. In other words, action identifiers should be agreed upon in the application domain. If an AccessRequest specifies an action not covered by any policy's <code>shpl:action</code>, then none of those policies would apply (resulting in default deny unless another mechanism allows it).</dd>
                <dt><code>shpl:condition</code> (SHACL NodeShape, required)</dt>
                <dd>The core of the policy—a link to a SHACL NodeShape that encodes the condition to be evaluated. Each Policy MUST have exactly one <code>shpl:condition</code> property. The object is typically a blank node or URI of a SHACL shape defined according to the SHACL specification (i.e., using <code>rdf:type sh:NodeShape</code> and various <code>sh:property</code>, <code>sh:constraintComponent</code> etc., to describe the constraint). This shape is expected to validate an AccessRequest node (see below) or some part of it. If the shape validates successfully (no SHACL violations) on the provided data, we say the policy's condition is satisfied for that request. If the shape results in any validation errors, the condition is not met.
                <p>The shape definition can leverage all of SHACL's features. It SHOULD be written such that it targets the relevant node in the AccessRequest structure. For convenience, a policy's shape will often use <code>sh:targetClass shpl:AccessRequest</code> to indicate it should be run on any node of type <code>shpl:AccessRequest</code> (or the specific request node can be passed to the SHACL engine as the focus). The shape may navigate from the AccessRequest to related data (like credentials, agent properties, etc.) via property paths.</p>
                <p>Example: A shape might contain a property constraint like: <code>sh:path shpl:credential; sh:qualifiedValueShape (some constraint); sh:qualifiedMinCount 1.</code> which ensures at least one credential attached to the request meets some condition. See the Examples section for concrete shape illustrations.</p>
                </dd>
            </dl>
        </section>
        <section id="access-request-model">
            <h3>Access Request and Related Properties</h3>
            <p>While policies are the main artifacts authored and stored, evaluating a policy requires a representation of the current access request. This specification defines an <code>shpl:AccessRequest</code> class to standardize that representation for the purpose of shape evaluation:</p>
             <dl>
                <dt><code>shpl:AccessRequest</code></dt>
                <dd>An RDF class that represents an access request context. It is not required that an AccessRequest be stored long-term; it can be a transient graph structure composed when checking a policy. However, for the shapes to operate, the data should be modeled with this structure. An AccessRequest instance SHOULD have the following properties:
                    <ul>
                        <li><code>shpl:agent</code>: The entity attempting access. This could be a URI (e.g., a DID or a user's WebID) or a blank node representing the user. The exact nature of the agent identifier is domain-specific. The agent may be referenced in credentials (e.g., as <code>credentialSubject id</code>) but that linkage is something the verification process might ensure (for example, by requiring that the agent's ID matches the subject of the credential - such matching can also be encoded as part of the shape if needed).</li>
                        <li><code>shpl:target</code>: The resource the agent is trying to access. This should equal one of the policy's targets for the policy to apply, but in an AccessRequest it will be a single resource IRI. (Using the same property <code>shpl:target</code> for both Policy and AccessRequest is conceptually convenient - one denotes the rule's scope, the other the instance being accessed.)</li>
                        <li><code>shpl:action</code>: The action being performed (e.g., <code>shpl:Read</code>, <code>shpl:Write</code>). Again, the AccessRequest's action must match the policy's action for relevance. Using the same action identifier vocabulary ensures consistency.</li>
                        <li><code>shpl:credential</code>: One or more Verifiable Credentials presented by the agent in support of the access request. Each value of <code>shpl:credential</code> should be an RDF node representing a credential (for example, a node of type <code>cred:VerifiableCredential</code> with associated claims about the subject). The credentials linked here are assumed to be already verified (i.e., the system should check their signatures, expiration, etc., before evaluation) and relevant to the policy check. The SHACL conditions will inspect these credential nodes to see if required attributes are present.</li>
                    </ul>
                    An AccessRequest may include additional contextual information if needed (for instance, <code>shpl:environment</code> or other properties could be defined in extensions to capture time, location, or other factors). This specification focuses on credentials and core fields. If such extra data is needed, it can be included in the data graph and referenced by shapes (for example, a shape could reference a timestamp node for time-based rules).
                </dd>
            </dl>
            <p><strong>Cardinalities and Requirements:</strong> When constructing an AccessRequest data graph for evaluation: - There SHOULD be exactly one <code>shpl:agent</code>, one <code>shpl:target</code>, and one <code>shpl:action</code> property on the AccessRequest node, corresponding to the specific request. There MAY be multiple <code>shpl:credential</code> entries (for instance, the requester provides several credentials). Each credential node SHOULD be in a format consistent with the VC Data Model (detailed in the next section), and typically of type <code>cred:VerifiableCredential</code>. The credential's claims about the subject are expected to be present in a structured form (either directly as properties of the credential node or via a <code>cred:credentialSubject</code> blank node with those properties).</p>
        </section>
         <section id="actions-vocab">
            <h3>Actions</h3>
            <p>This specification defines a base <code>shpl:Action</code> class for actions and a few common action instances:</p>
             <dl>
                <dt><code>shpl:Action</code> (class)</dt>
                <dd>a generic class for actions that can be taken on resources. This can be extended or simply used to type individual action IRIs.</dd>
                 <dt><code>shpl:Read</code></dt>
                <dd>an individual of type <code>shpl:Action</code>, representing read/view access to a resource. Policies with <code>shpl:action shpl:Read</code> apply to requests to read or retrieve the resource (e.g., HTTP GET or similar).</dd>
                 <dt><code>shpl:Write</code></dt>
                <dd>an individual of type <code>shpl:Action</code>, representing write/modify access to a resource. This could encompass create, update, delete operations in a broad sense. - (Other action instances could be defined similarly, such as <code>shpl:Append</code>, <code>shpl:Delete</code>, <code>shpl:Admin</code>, depending on the granularity needed. For the purposes of this spec, we list only Read and Write for illustration. Domains can use their own action identifiers too; e.g., a data space might define <code>ex:Transfer</code> or other custom actions.)</dd>
            </dl>
            <p><strong>Note:</strong> The <code>shpl:action</code> property of a policy or AccessRequest is not restricted to instances of <code>shpl:Action</code>; using an external action vocabulary is allowed. However, using the provided ones ensures a common understanding for basic operations. If using external actions, all relevant policies and requests must align on those terms.</p>
        </section>
        <section id="normative-summary">
            <h3>Normative Requirements Summary</h3>
            <p>To summarize the key normative constraints for a valid SHACL Policy Language and usage:</p>
            <ul>
                <li><strong>Policy Instances:</strong> A conformant policy instance MUST:
                    <ul>
                        <li>Be of type <code>shpl:Policy</code> (or a subclass thereof, e.g., <code>shpl:AllowPolicy</code> or <code>shpl:DenyPolicy</code>).</li>
                        <li>Have exactly one <code>shpl:action</code> property (value is an IRI).</li>
                        <li>Have at least one <code>shpl:target</code> property (one or more values as IRIs or classes).</li>
                        <li>Have exactly one <code>shpl:condition</code> property (value is a SHACL NodeShape definition).</li>
                        <li>Optionally be further typed as <code>shpl:AllowPolicy</code> or <code>shpl:DenyPolicy</code> to indicate effect (recommended). If not, it defaults to allow semantics.</li>
                    </ul>
                </li>
                <li><strong>NodeShape for condition:</strong> The shape linked by <code>shpl:condition</code> SHOULD be crafted to evaluate an <code>shpl:AccessRequest</code>. It MAY use <code>sh:targetClass shpl:AccessRequest</code> or rely on being invoked on a specific node. The shape MUST be a valid SHACL shape definition (conforming to SHACL Core or SHACL-SPARQL as needed).</li>
                <li><strong>AccessRequest structure:</strong> When evaluating, the input data graph MUST contain a representation of the request. At minimum, an AccessRequest node (which MAY be a blank node) with properties <code>shpl:agent</code>, <code>shpl:target</code>, <code>shpl:action</code>, and <code>shpl:credential</code> (as applicable). The values for these should accurately reflect the actual request being checked.</li>
                <li><strong>Credential data:</strong> Any credential provided in the AccessRequest SHOULD be verified (signature valid, not expired/revoked) before or during the policy evaluation process. The SHACL Policy Language spec does not mandate how verification is done, but for a credential to be trusted in the policy check, an implementation MUST perform the necessary cryptographic verification per the VC Data Model. If a credential cannot be verified or is invalid, the implementation SHOULD treat it as not present or not satisfying any condition.</li>
            </ul>
        </section>
    </section>

    <section id="vc-integration">
        <h2>Integration with Verifiable Credentials</h2>
        <p>SHACL Policy Language is designed to work hand-in-hand with the W3C Verifiable Credentials (VC) Data Model. This section describes how credentials are represented and used in policy evaluation, and outlines best practices for ensuring that only valid credentials influence access decisions.</p>
        <section id="representing-credentials">
            <h3>Representing Credentials in RDF</h3>
            <p>Verifiable Credentials are typically issued as JSON (often JSON-LD) objects. The VC Data Model 1.1/2.0 defines a standard context such that a credential can be interpreted as RDF triples. In an RDF representation (after JSON-LD processing), a credential is an entity of type <code>cred:VerifiableCredential</code> (using namespace prefix <code>cred:</code> for <code>https://www.w3.org/2018/credentials#</code>). Key fields of a VC such as <code>credentialSubject</code>, <code>issuer</code>, <code>issuanceDate</code>, <code>expirationDate</code>, etc., become RDF properties in the <code>cred:</code> namespace (e.g., <code>cred:credentialSubject</code>, <code>cred:issuer</code>). Claims about the subject are typically represented as a separate node (blank node or IRI) linked via <code>cred:credentialSubject</code>, containing the claim predicates (which might be from any schema, e.g., <code>schema:age</code>, <code>ex:memberOf</code>, etc.).</p>
            <p>Example RDF mapping of a VC: Consider a VC (in JSON) that states Alice's age is 20, issued by ExampleGov. In RDF/Turtle form, it might look like:</p>
            <pre class="nohighlight">
:AliceAgeCredential a cred:VerifiableCredential;
  cred:issuer &lt;did:example:gov&gt;;
  cred:credentialSubject [
    a schema:Person;
    schema:age 20;
    schema:name "Alice";
    schema:birthDate "2005-01-01"^^xsd:date
  ];
  cred:issuanceDate "2025-06-01T00:00:00Z"^^xsd:dateTime.
            </pre>
            <p><strong>Namespaces and Prefixes:</strong> The SHACL Policy Language shapes and the AccessRequest data should use the same RDF representation for credentials. It is RECOMMENDED to use well-known vocabulary for common claims: E.g., <code>schema:age</code> or <code>schema:birthDate</code> for age, or a custom namespace like <code>ex:membership</code> or roles, perhaps <code>schema:affiliation</code> or custom <code>ex:memberOf</code>. The exact predicates depend on issuer practice, but as long as the shape writer and the credentials align, it will work. One may also write shapes flexibly (like checking for one of several possible properties for age).</p>
            <p>This specification itself does not define new terms for VC claims; it assumes credentials are self-descriptive via their schemas. It focuses on how policies consume those claims.</p>
        </section>
        <section id="using-credentials">
            <h3>Using Credentials in an AccessRequest</h3>
            <p>When assembling the <code>AccessRequest</code> data graph for a policy check, any Verifiable Credential presented by the user should be included as an RDF node linked via <code>shpl:credential</code>. Typically, the process is:</p>
            <ol>
                <li><strong>Credential Verification:</strong> The system receives a VC (e.g., via a Verifiable Presentation or an authorization protocol like OAuth-OIDC for VCs). The system MUST verify the credential's signature and check its status (e.g., not revoked) and validity (within issuance/expiration bounds) according to the VC Data Model and any applicable trust framework. If verification fails, the credential is discarded or marked as invalid.</li>
                <li><strong>RDF Conversion:</strong> The claims from the credential are converted to RDF. If the credential is JSON-LD and context is known, this can be done by a JSON-LD processor. Alternatively, a manual mapping can populate an RDF graph with the needed triples (as illustrated above). The output should include at least the claims relevant to the policy and ideally also the type, issuer, and other metadata if needed for conditions.</li>
                <li><strong>Linking in AccessRequest:</strong> In the AccessRequest node, add a triple linking <code>shpl:credential</code> to the credential's RDF node. If multiple credentials are presented, add multiple such triples (or use an RDF collection, though multiple triples is simpler and natural in RDF).</li>
                <li><strong>Agent-Subject Binding:</strong> One critical aspect is ensuring the credential actually belongs to the agent. The system should ensure that the <code>cred:credentialSubject</code> corresponds to the agent making the request. This might be done by checking if the agent's ID (like a DID or profile URI) is explicitly mentioned in the credential (many VCs have an <code>id</code> inside <code>credentialSubject</code> or use the subject's DID as the subject ID). If present, the shape could enforce that (e.g., a shape constraint like <code>sh:path (shpl:credential cred:credentialSubject cred:id); sh:hasValue &lt;agent ID&gt;</code>). Alternatively, presentation protocols (like DIDs and proofs) might ensure the holder is the subject (e.g., via a challenge-response or binding mechanism). This specification does not mandate how holder binding is achieved, but policy authors SHOULD account for it in high-security scenarios. At minimum, if the VC has a subject identifier, a shape constraint can check it matches the known agent's URI.</li>
            </ol>
            <p><strong>Multiple Credentials and Logical Conditions:</strong> The SHACL shapes can handle multiple credentials by using qualified value shapes or logical operators. For example, to require both a diploma and an employee ID credential, one could write a shape that has two property constraints on <code>shpl:credential</code> - each with <code>sh:qualifiedValueShape</code> matching one type of credential and <code>sh:qualifiedMinCount 1</code>. This means "at least one credential of type Diploma AND at least one of type EmployeeID must be present". The intersection (<code>sh:and</code>) of those conditions ensures both are there.</p>
            <h4>Example Integration Walk-through</h4>
            <p>Consider the Role-Based Data Access use case: Only managers (with a ManagerRole VC) can edit a resource. Here's how integration would happen:</p>
            <ul>
                <li>The user (agent) presents a Verifiable Credential: `ManagerRoleCredential` issued by CompanyX, with claim `role = Manager` and subject `did:example:alice` (the user's DID).</li>
                <li>The system verifies the credential (signature from CompanyX, check not expired).</li>
                <li>The system converts it to RDF:
                    <pre class="nohighlight">
:ManagerRoleCred a cred:VerifiableCredential;
  cred:issuer &lt;did:example:CompanyX&gt;;
  cred:credentialSubject [
    cred:id &lt;did:example:alice&gt;;
    ex:role "Manager";
    ex:employeeOf &lt;did:example:CompanyX&gt;
  ].
                    </pre>
                </li>
                <li>The AccessRequest is built for Alice's attempt to perform action <code>shpl:Write</code> on resource <code>&lt;https://data.example.com/doc123&gt;</code>:
                    <pre class="nohighlight">
[] a shpl:AccessRequest;
  shpl:agent &lt;did:example:alice&gt;;
  shpl:action shpl:Write;
  shpl:target &lt;https://data.example.com/doc123&gt;;
  shpl:credential :ManagerRoleCred.
                    </pre>
                </li>
                <li>The relevant policy (for editing documents) might have <code>shpl:action shpl:Write</code>, <code>shpl:target ex:Document</code> (class for all docs, and doc123 is a ex:Document), and a shape that says "exists a credential with role Manager issued by CompanyX to this agent".</li>
                <li>The shape would check in the data: - There is at least one <code>shpl:credential</code> whose <code>cred:credentialSubject/ex:role</code> is "Manager" and whose <code>cred:issuer</code> is CompanyX and whose <code>cred:credentialSubject/cred:id</code> is the agent's DID.</li>
                <li>In this case, our data has exactly that, so the shape passes. The policy is an AllowPolicy, so access is permitted.</li>
            </ul>
        </section>
        <section id="security-considerations">
            <h3>Trust and Security Considerations</h3>
            <p>It is important to emphasize: SHACL Policy Language by itself does not verify cryptographic signatures or proof of ownership for credentials. It assumes that step has been done. The shapes operate on data that could be tampered with if not verified. Therefore, any implementation MUST ensure credentials in the AccessRequest graph are authentic and belong to the agent. This typically means integrating with a Verifiable Credentials verification library or service. If an unverified credential were injected into the AccessRequest graph, the shapes might erroneously grant access. So the pipeline is: verify credentials -> populate RDF graph -> run SHACL validation. The evaluation process should also run in a secure environment. For example, if using SHACL-SPARQL constraints, ensure the SPARQL execution cannot be abused (since SPARQL can be quite powerful). - Privacy: Policies might reveal what attributes are being checked (especially if a denial is logged or communicated). Care should be taken not to leak unnecessary info. However, since credentials are presented by the user, they generally know which attributes might be considered.</p>
            <p>This integration section clarifies that SHACL Policy Language builds atop the VC infrastructure: it does not replace any part of the VC model (issuance, exchange, verification) it only leverages the resulting verified claims to make access decisions in a standardized way.</p>
        </section>
    </section>

    <section id="evaluation-semantics">
        <h2>SHACL Policy Language Evaluation Semantics</h2>
        <p>This section defines how to evaluate one or more SHACL Policies against an incoming access request to produce an authorization decision (permit or deny). The process can be summarized as: collect applicable policies → evaluate each policy's shape on the request data → combine results according to policy effects (allow/deny) to reach a final decision.</p>
        <section>
            <h3>Applicability of Policies</h3>
            <p>When a subject (agent) attempts to perform an action on a resource, the policy decision point (PDP) should first determine which policies are relevant. To do this:</p>
            <ol>
                <li><strong>Match by Action:</strong> Only consider policies where the <code>shpl:action</code> equals the action of the request.</li>
                <li><strong>Match by Target:</strong> Among those, only consider policies where the requested resource matches one of the policy's <code>shpl:target</code> values. This could be a direct URI match or a type/class match (e.g., if the resource is of type <code>ex:Document</code> and the policy target is <code>ex:Document</code> class).</li>
                <li>Optionally, match by other criteria if policies are scoped in other ways (not in core spec, but e.g., a policy might apply only to certain agents or contexts, which could be encoded in the shape or meta-properties).</li>
            </ol>
            <p>All policies that pass these filters are the applicable policies for this request. If no policies are applicable, the system SHOULD deny access by default (fail-safe principle), unless a separate default allow rule exists in the environment (this spec assumes default deny if not configured otherwise).</p>
        </section>
        <section>
            <h3>Data Preparation</h3>
            <p>The PDP constructs an AccessRequest data graph representing this access attempt, as described earlier (with agent, target, action, credentials, etc.). This graph will be used for SHACL validation. The PDP MUST ensure that: The data graph is complete with all necessary information for the shapes (e.g., if shapes expect certain claims, those claims are present if available). Credential data in the graph is from verified credentials (as discussed in Integration).</p>
        </section>
        <section>
            <h3>Shape Evaluation</h3>
            <p>For each applicable policy:</p>
            <ul>
                <li>The <code>shpl:condition</code> NodeShape is retrieved.</li>
                <li>The SHACL validation engine is invoked on the AccessRequest data (the shapes graph consists at least of this shape; it could also include a shapes graph with multiple shape definitions, but here it's typically one main shape per policy).</li>
                <li>The focus of validation: If the shape has <code>sh:targetClass shpl:AccessRequest</code>, the engine will automatically test all AccessRequest nodes in data (there should be one). Alternatively, the PDP can direct the engine to specifically validate the AccessRequest node against the shape.</li>
                <li>Result: The outcome will be either "conforms" (no violations) or "does not conform" (violations found). We map this to:
                    <ul>
                        <li><strong>Condition Satisfied (TRUE):</strong> if the data conforms to the shape (meaning the policy's constraints are all met by the provided credentials/context).</li>
                        <li><strong>Condition Not Satisfied (FALSE):</strong> if the data does not conform (meaning at least one required condition is not met).</li>
                    </ul>
                </li>
            </ul>
            <p>It is possible to retrieve a validation report with details, but for access control, usually just a boolean satisfaction is needed. Implementations MAY log or examine the report for debugging (e.g., to see which constraint failed, to inform the user why access was denied, if that's appropriate).</p>
        </section>
        <section>
            <h3>Combining Policy Outcomes</h3>
            <p>Once each applicable policy's condition is evaluated:</p>
            <ol>
                <li>Partition the policies by effect: those that are Allow (including default Policy treated as allow) and those that are Deny.</li>
                <li>Determine if any deny conditions are satisfied: If any DenyPolicy condition is TRUE, the request MUST be denied. A deny rule overrides any allows. (This is a common safety approach also used in XACML and others deny policies have priority.)</li>
                <li>The PDP can short-circuit evaluation if one deny comes out true (no need to evaluate further, except perhaps for logging all violations).</li>
                <li>If no deny conditions are true, then check allows: If at least one AllowPolicy condition is TRUE, then the request MAY be permitted (proceed to allow). In other words, one valid allow is sufficient to authorize, provided no denies triggered.</li>
                <li>If no AllowPolicy is true (and also no deny was true), then the request is denied by default (meaning it didn't meet any known rule to permit it). This is effectively a default deny if nothing says "yes".</li>
            </ol>
            <p>These rules can be summarized in pseudocode or a list:</p>
            <ol>
                <li>For each applicable policy P:
                    <ul>
                        <li>Evaluate condition shape on request data→ get boolean result.</li>
                        <li>If P is a DenyPolicy and result is true: deny (stop and deny).</li>
                    </ul>
                </li>
                <li>If any allow policy had result true (and no deny was triggered): allow.</li>
                <li>Otherwise: deny (no allows satisfied, or no applicable policies at all).</li>
            </ol>
            <p><strong>Conflict Resolution:</strong> The above strategy inherently resolves conflicts by prioritizing denies. This is the RECOMMENDED conflict resolution strategy for security (often called "deny overrides"). In some environments, policies might be written such that conflicts are unlikely (e.g., using only allow rules or only deny rules for a given action). If a different conflict resolution is needed (not covered by this spec), it should be carefully designed and perhaps indicated by a policy set configuration. This specification sticks to deny-overrides for simplicity and safety.</p>
        </section>
        <section>
            <h3>Obligations and Advanced Concepts</h3>
            <p>ODRL and some policy languages have the notion of obligations or duties (actions that must be performed upon allowing access). SHACL Policy Language in this version does not explicitly model obligations. It focuses purely on allow/deny decisions. If obligations are needed (e.g., "log this access" or "notify someone when accessed"), those could be implemented outside of this policy evaluation or potentially encoded as part of the condition (though that's a bit of a hack) or future vocabulary extension (like <code>shpl:ObligationPolicy</code> with actions to trigger). For now, obligations are out of scope; the spec's aim is authorization (not auditing or usage control post-decision).</p>
        </section>
        <section>
            <h3>Performance Considerations</h3>
            <p>Evaluating SHACL shapes for each request could introduce overhead, especially if shapes are complex (e.g., using SPARQL) or if there are many policies. Implementations should consider:</p>
            <ul>
                <li>Pre-compiling or optimizing shapes if possible.</li>
                <li>Caching policy decisions for repeated requests (with caution, ensure that credentials and context haven't changed).</li>
                <li>Minimizing the data graph size (include only necessary triples in the AccessRequest graph).</li>
            </ul>
            <p>However, given that many use cases involve a handful of credentials and a moderate number of policies, SHACL evaluation is likely to be fast (SHACL engines can typically handle hundreds of constraints quickly, as they are essentially rule checks). Also, since policies are decoupled, the engine could evaluate them in parallel if needed.</p>
        </section>
        <section>
            <h3>Example Scenario Outcome</h3>
            <p>To illustrate the semantics, imagine:</p>
            <ul>
                <li><strong>Policies:</strong> P1 (Allow if age ≥ 18), P2 (Deny if age < 13).</li>
                <li><strong>Alice (age 20) tries access:</strong> P1's shape sees a credential with age 20 (≥18) -> condition true. P2's shape checks if any credential shows age < 13. None do -> condition false. No deny true, an allow is true -> <strong>Access allowed.</strong></li>
                <li><strong>Bob (age 10) tries access:</strong> P1: any credential age ≥18? He has age 10, so no -> condition false. P2: any credential age < 13? Yes, age 10 qualifies -> condition true. A deny is true -> <strong>Access denied.</strong></li>
                <li><strong>Carol (no credential) tries access:</strong> P1: no credential with age ≥18 -> condition false. P2: no credential with age <13 either -> condition false. No denies triggered, but also no allows satisfied -> <strong>Access denied (default).</strong></li>
            </ul>
        </section>
    </section>

    <section id="examples">
        <h2>Examples</h2>
        <p>This section provides normative (but illustrative) examples of SHACL Policy Language in action. The examples are written in Turtle syntax for clarity, showing how one might define policies and how a request would be evaluated against them. Each example is accompanied by an explanation.</p>
        <p>For brevity, we will use a hypothetical prefix <code>ex:</code> for example terms (e.g., <code>ex:Resource123</code> as a resource, and some example claim properties under <code>ex:</code>). We also use <code>vc:</code> prefix for Verifiable Credentials vocabulary (<code>vc:</code> here mapped to <code>https://www.w3.org/2018/credentials#</code> as an alias of <code>cred:</code>). Assume the SHACL Policy Language vocabulary prefix <code>shpl:</code> is defined as described.</p>

        <section id="example1">
            <h3>Example 1: Age-Based Access (Adult Content Policy)</h3>
            <p><strong>Scenario:</strong> A resource (e.g., a video or website section) should only be accessible by users 18 years or older. Users can prove their age via a verifiable credential (for example, an ID credential with a birthdate or age claim).</p>
            <p><strong>Policy Definition (Allow if age ≥ 18):</strong></p>
            <pre class="nohighlight">
@prefix ex: &lt;http://example.com/ns#&gt; .
@prefix shpl: &lt;https://w3id.org/shacl-policy-language#&gt; .
@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
@prefix vc: &lt;https://www.w3.org/2018/credentials#&gt; .

ex:AdultAccessPolicy a shpl:AllowPolicy;
  shpl:target ex:AdultOnlyResource;
  shpl:action shpl:Read;
  shpl:condition [
    a sh:NodeShape;
    sh:targetClass shpl:AccessRequest;
    sh:description "Allow access if at least one credential shows age >= 18";
    sh:property [
      sh:path shpl:credential;
      sh:qualifiedValueShape [
        a sh:NodeShape;
        sh:property [
          sh:path vc:credentialSubject;
          sh:node [
            sh:property [
              sh:path ex:age;
              sh:minInclusive 18;
            ]
          ]
        ]
      ];
      sh:qualifiedMinCount 1;
      sh:message "User must present a credential proving age 18 or above.";
    ];
  ].
            </pre>
            <p><strong>Explanation:</strong> This <code>shpl:AllowPolicy</code> named <code>ex:AdultAccessPolicy</code> targets <code>ex:AdultOnlyResource</code> for read access. The condition shape attached to it says: "In the AccessRequest, there must be at least one credential whose credentialSubject has an <code>ex:age</code> property with value ≥18". We use <code>sh:qualifiedValueShape</code> on the <code>shpl:credential</code> property to implement the "at least one credential" logic. If a user presents a credential that meets this criterion (e.g., a driver's license credential stating their age or birth year indicating age ≥18), then the shape will validate, satisfying the policy. If no such credential is present, the shape fails and thus the policy does not grant access.</p>
            <p><strong>Sample AccessRequest:</strong> Suppose Alice, 20 years old, presents a credential with <code>ex:age 20</code>. The AccessRequest (in Turtle) might be:</p>
            <pre class="nohighlight">
@prefix ex: &lt;http://example.com/ns#&gt; .
@prefix shpl: &lt;https://w3id.org/shacl-policy-language#&gt; .
@prefix vc: &lt;https://www.w3.org/2018/credentials#&gt; .

# Alice's Age Credential (verifiable credential data)
:AliceAgeCredential a vc:VerifiableCredential;
  vc:credentialSubject [
    ex:age 20;
    ex:name "Alice"
  ].

# Access request for Alice trying to read AdultOnlyResource
:Request1 a shpl:AccessRequest;
  shpl:agent &lt;did:example:alice&gt;;
  shpl:action shpl:Read;
  shpl:target ex:AdultOnlyResource;
  shpl:credential :AliceAgeCredential.
            </pre>
            <p>When evaluating <code>ex:AdultAccessPolicy</code> against this request, the SHACL engine finds that <code>:AliceAgeCredential</code> has <code>ex:age 20</code> which satisfies the <code>sh:minInclusive 18</code>. Therefore, the condition is true, and since this is an AllowPolicy, Alice is permitted access. If Alice had not provided that credential, or if the age was below 18, the condition would fail and the policy would not grant access (and presumably no other allow policy would, resulting in denial).</p>
        </section>

        <section id="example2">
            <h3>Example 2: Deny Policy for Underage Users (COPPA Compliance)</h3>
            <p><strong>Scenario:</strong> For compliance (e.g., COPPA in the US), users under 13 years old should be explicitly denied access to a certain resource, regardless of other credentials. This is a deny rule to ensure young minors cannot access. This could accompany the above allow policy, adding an extra safety net.</p>
            <p><strong>Policy Definition (Deny if age < 13):</strong></p>
            <pre class="nohighlight">
ex:Under13DenyPolicy a shpl:DenyPolicy;
  shpl:target ex:AdultOnlyResource;
  shpl:action shpl:Read;
  shpl:condition [
    a sh:NodeShape;
    sh:targetClass shpl:AccessRequest;
    sh:description "Deny access if any credential shows age under 13";
    sh:property [
      sh:path shpl:credential;
      sh:qualifiedValueShape [
        a sh:NodeShape;
        sh:property [
          sh:path vc:credentialSubject;
          sh:node [
            sh:property [
              sh:path ex:age;
              sh:maxExclusive 13;
            ]
          ]
        ]
      ];
      sh:qualifiedMinCount 1;
      sh:message "Access denied: user appears to be under 13 years old.";
    ];
  ].
            </pre>
            <p><strong>Explanation:</strong> <code>ex:Under13DenyPolicy</code> is a DenyPolicy on the same resource and action (read on AdultOnlyResource). The shape here checks for the presence of any credential indicating an age < 13 (<code>sh:maxExclusive 13</code> means strictly less than 13). If at least one such credential is found, the shape conforms (meaning the deny condition is met) and thus the policy will trigger a denial.</p>
            <p><strong>Usage:</strong> Combined with Example 1, the evaluation works as described in the semantics: The deny policy is checked; if its condition is true (user is under 13), immediate deny. Otherwise, the allow policy is checked for ≥18. So effectively, 0-12 year olds are always denied (due to Under13DenyPolicy triggering). 13-17 year olds are not caught by deny (because not <13), but also fail the ≥18 allow, so they end up denied (no allow triggered). 18+ year olds are not caught by deny, and satisfy allow, so allowed. This showcases how an allow and deny policy can complement each other.</p>
        </section>

        <section id="example3">
            <h3>Example 3: Organization Membership Requirement</h3>
            <p><strong>Scenario:</strong> Only members of Example Organization are allowed access to a certain internal resource. The user must present a credential (perhaps an organizational ID card or membership VC) that proves <code>ex:memberOf ExampleOrg</code>. This is an allow policy condition.</p>
            <p><strong>Policy Definition (Allow if member of ExampleOrg):</strong></p>
             <pre class="nohighlight">
ex:OrgMemberPolicy a shpl:AllowPolicy;
  shpl:target ex:InternalResource;
  shpl:action shpl:Read;
  shpl:condition [
    a sh:NodeShape;
    sh:targetClass shpl:AccessRequest;
    sh:description "Allow access if user has a credential proving membership in ExampleOrg";
    sh:property [
      sh:path shpl:credential;
      sh:qualifiedValueShape [
        a sh:NodeShape;
        sh:property [
          sh:path vc:credentialSubject;
          sh:node [
            sh:property [
              sh:path ex:memberOf;
              sh:hasValue ex:ExampleOrg;
            ]
          ]
        ]
      ];
      sh:qualifiedMinCount 1;
      sh:message "User must present an ExampleOrg membership credential.";
    ];
  ].
            </pre>
            <p><strong>Explanation:</strong> This policy, <code>ex:OrgMemberPolicy</code>, grants read access to <code>ex:InternalResource</code> only if the user has a credential whose credentialSubject has property <code>ex:memberOf</code> equal to <code>ex:ExampleOrg</code>. We assume here <code>ex:ExampleOrg</code> is an identifier (URI) for the organization. The shape uses <code>sh:hasValue ex:ExampleOrg</code> to require an exact match. This implies the credential must explicitly state that membership.</p>
            <p><strong>Sample Credential:</strong> The user might have a VC like:</p>
            <pre class="nohighlight">
:MemberCred a vc:VerifiableCredential;
  vc:issuer &lt;did:example:ExampleOrg&gt;;
  vc:credentialSubject [
    cred:id &lt;did:example:user123&gt;;
    ex:memberOf ex:ExampleOrg;
    ex:memberSince "2020-01-01"^^xsd:date
  ].
            </pre>
            <p><strong>Multiple Orgs / Extensibility:</strong> If in the future one wanted to allow membership in a set of organizations (say ExampleOrg or PartnerOrg), the shape could use <code>sh:in (ex:ExampleOrg ex:PartnerOrg)</code> instead of <code>sh:hasValue</code>, or use a regex or class-based approach. SHACL allows those adjustments easily.</p>
        </section>

         <section id="example4">
            <h3>Example 4: Multiple Credentials (Logical AND of Conditions)</h3>
            <p><strong>Scenario:</strong> A highly sensitive resource requires two conditions: (a) The user must have a Clearance Level 5 credential from a trusted authority, and (b) the user must have an Employment credential from CompanyXYZ (i.e., they currently work for the company that owns the resource). Both must be true to permit access.</p>
            <p>The straightforward way: one policy with a single shape that itself encodes both requirements.</p>
            <p><strong>Policy Definition (Allow if has Clearance5 AND CompanyXYZ employment):</strong></p>
             <pre class="nohighlight">
ex:SensitivityAccessPolicy a shpl:AllowPolicy;
  shpl:target ex:HighlySensitiveResource;
  shpl:action shpl:Read;
  shpl:condition [
    a sh:NodeShape;
    sh:targetClass shpl:AccessRequest;
    sh:description "Allow if user has (ClearanceLevel5 credential) AND (CompanyXYZ employment credential)";
    # Using two property constraints on shpl:credential for each requirement
    sh:property [
      sh:path shpl:credential;
      sh:qualifiedValueShape [
        sh:property [
          sh:path vc:credentialSubject;
          sh:node [
            sh:property [
              sh:path ex:clearanceLevel;
              sh:hasValue "5";
            ]
          ]
        ];
        # also ensure issuer is the trusted authority
        sh:property [
            sh:path vc:issuer;
            sh:hasValue &lt;did:example:SecurityAgency&gt;;
        ]
      ];
      sh:qualifiedMinCount 1;
      sh:message "Needs a Level 5 Clearance credential from SecurityAgency.";
    ];
    sh:property [
      sh:path shpl:credential;
      sh:qualifiedValueShape [
        sh:property [
          sh:path vc:credentialSubject;
          sh:node [
            sh:property [
              sh:path ex:employer;
              sh:hasValue ex:CompanyXYZ;
            ]
          ]
        ]
      ];
      sh:qualifiedMinCount 1;
      sh:message "Needs an employment credential from CompanyXYZ.";
    ];
  ].
            </pre>
            <p><strong>Explanation:</strong> In this shape, we placed two separate <code>sh:property</code> constraints on the AccessRequest's <code>shpl:credential</code>: The first one looks for a credential that has <code>ex:clearanceLevel "5"</code> in its subject and that the credential's issuer is the SecurityAgency. The second one looks for a credential that has <code>ex:employer CompanyXYZ</code> in its subject. Each uses <code>qualifiedValueShape</code>/<code>qualifiedMinCount 1</code> to mean "at least one credential meets this pattern". Both of these property constraints must be satisfied simultaneously on the AccessRequest for the NodeShape to validate (SHACL by default has an implicit AND for multiple top-level constraints in a shape). That means the user must supply at least one credential of each type.</p>
        </section>
    </section>

    <section id="appendix-vocabulary" class="appendix">
      <h2>RDF/Turtle Vocabulary</h2>
      <p>
        Below is an illustrative Turtle serialization of the SHACL Policy Language vocabulary. It defines the primary classes and properties introduced in this specification. This is provided for reference and as a starting point for implementations. Prefix <code>shpl:</code> is assumed to resolve to the official namespace of SHACL Policy Language (which might be a w3id or similar persistent URI).
      </p>
      <pre class="nohighlight">
@prefix shpl: &lt;https://w3id.org/shacl-policy-language#&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .
@prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .
@prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
@prefix cred: &lt;https://www.w3.org/2018/credentials#&gt; .

# Classes
shpl:Policy a rdfs:Class;
  rdfs:label "Policy";
  rdfs:comment "An access control policy rule, linking a condition to an allow or deny effect for a given action on a resource.".

shpl:AllowPolicy a rdfs:Class;
  rdfs:subClassOf shpl:Policy;
  rdfs:label "AllowPolicy";
  rdfs:comment "A policy that grants permission if its condition is satisfied. Subclass of Policy.".

shpl:DenyPolicy a rdfs:Class;
  rdfs:subClassOf shpl:Policy;
  rdfs:label "DenyPolicy";
  rdfs:comment "A policy that enforces a denial if its condition is satisfied. Subclass of Policy.".

shpl:AccessRequest a rdfs:Class;
  rdfs:label "AccessRequest";
  rdfs:comment "A class representing an access request context (agent, action, resource, credentials) used for policy evaluation.".

shpl:Action a rdfs:Class;
  rdfs:label "Action";
  rdfs:comment "Class of actions that can be performed on resources (e.g., Read, Write). Used to categorize the shpl:action property values.".

# Properties
shpl:target a rdf:Property;
  rdfs:label "target";
  rdfs:domain shpl:Policy;
  rdfs:range rdfs:Resource;
  rdfs:comment "Indicates the resource (or class of resources) to which a Policy applies. On AccessRequest, it indicates the resource being accessed.".

shpl:action a rdf:Property;
  rdfs:label "action";
  rdfs:range shpl:Action;
  rdfs:comment "Indicates the action governed by a Policy, or the action being attempted in an AccessRequest. Uses individuals of class shpl:Action (or other action IRIs).".

shpl:condition a rdf:Property;
  rdfs:label "condition";
  rdfs:domain shpl:Policy;
  rdfs:range sh:NodeShape;
  rdfs:comment "Links a Policy to a SHACL NodeShape that represents the access condition to evaluate.".

shpl:agent a rdf:Property;
  rdfs:label "agent";
  rdfs:domain shpl:AccessRequest;
  rdfs:comment "The agent (e.g., user or entity identifier) making the access request.".

shpl:credential a rdf:Property;
  rdfs:label "credential";
  rdfs:domain shpl:AccessRequest;
  rdfs:comment "A verifiable credential presented as part of the access request. Typically of type cred:VerifiableCredential with associated claims.".

# Common action individuals
shpl:Read a shpl:Action;
  rdfs:label "Read";
  rdfs:comment "Represents a 'read' action (view or retrieve a resource).".

shpl:Write a shpl:Action;
  rdfs:label "Write";
  rdfs:comment "Represents a 'write' action (modify or create a resource).".
      </pre>
      <p>Note: In the above, <code>shpl:target</code> and <code>shpl:action</code> are given a domain of <code>shpl:Policy</code> for clarity, but as discussed, <code>shpl:action</code> is also used on <code>shpl:AccessRequest</code>. RDFS domain is not a strict constraint in RDF semantics (it doesn't prevent other usage), but an implementation can understand that <code>shpl:action</code> on an AccessRequest is the attempted action. If desired, one could extend the vocabulary to have separate properties or use the same with an understanding of context.</p>
      <p>This Turtle file does not include every possible detail (e.g., it does not formalize that an AllowPolicy's effect is permit—that is procedural, not easily captured in RDFS/OWL alone). It is meant to provide the building blocks. Implementers can load this vocabulary to get the terms and then use SHACL shapes (the policy conditions) and code (for the evaluation algorithm) to complete the system behavior.</p>
    </section>
</body>
</html>